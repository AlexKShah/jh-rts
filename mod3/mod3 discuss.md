We want to disable interrupts for as little time as possible, allowing the shared data elements to be processed and quickly resume normal function of the loop, especially if we don't know the word size of our hardware. Otherwise we should make use of atomic operations that fit the hardware such as read/write events that fit in memory and ensuring our volatile variables don't get optimised away. In addition we should use a circular buffer to queue event handlers enabling us to process events in the order they occur without losing any. In this way we can queue updates while locking and unlocking interrupts which give us a handle on the shared data problem. Another good choice would be to operate with two buffers for tag data, allowing us to read or write from one at a time. Buffer A gets a new tag written to it while Buffer B allows reading the current tag data to allow entry to the door. Once the update is complete, Buffer A becomes the new up to date list and buffer B gets updated. This is slower and requires more space but can ensure the door is never deadlocked.